---
layout: "post"
title: "Mem2Reg 算法详解"
subtitle: "Mem2Reg"
author: "roife"
date: 2022-02-07

tags: ["编译@Tags", "SSA@编译", "LLVM@Tags", "编译优化@编译"]
lang: zh
catalog: true
header-image: ""
header-style: text
katex: true
---

# 介绍

Mem2Reg 是 LLVM 采用的 SSA 转换算法。如果使用 LLVM 作为后端，编译器前端在生成 LLVM IR 时可以先生成 `alloca/load/store` 这样借助内存存储局部变量值的 SSA 形式（即可以先不生成 $\varphi$ 函数）。在 LLVM 拿到前端生成的代码后，Mem2Reg 会将这些指令删除，并插入合适的 $\varphi$ 函数。

例如下面这段代码：

```c
int main() {
    int x, cond = 1;
    if (cond > 0)
        x = 1;
    else
        x = -1;
    return x;
}
```

前端生成的代码：

```llvm
define dso_local i32 @main() {
    %1 = alloca i32
    %2 = alloca i32
    store i32 1, i32* %1
    %3 = load i32, i32* %1
    %4 = icmp sgt i32 %3, 0
    br i1 %4, label %5, label %8

5:
    store i32 1, i32* %2
    br label %6

6:
    %7 = load i32, i32* %2
    ret i32 %7

8:
    %9 = sub i32 0, 1
    store i32 %9, i32* %2
    br label %6
}
```

Mem2Reg 转换后的代码：

```llvm
define dso_local i32 @main() {
    %1 = icmp sgt i32 1, 0
    br i1 %1, label %2, label %5

2:
    br label %3

3:
    %4 = phi i32 [ 1, %2 ], [ %6, %5 ]
    ret i32 %4

5:
    %6 = sub i32 0, 1
    br label %3
}
```

# 算法实现

这部分代码在 LLVM 的 `PromoteMemoryToRegister.cpp` 这个文件中，对应的 pass 为 `PromoteLegacyPass`。

首先假设我们已经算出了基本块的支配信息。

1. LLVM 假设所有的局部变量都连续地在函数**入口基本块的头部**使用 `alloca` 进行声明（函数 `promoteMemoryToRegister()`）
2. 对于步骤 1 中的所有 `alloca` 指令，LLVM 会找出其中 promotable 的那些指令。所谓 promotable，即满足下面的条件：
    - 这个 `alloca` 的 users 中有 `volatile` 指令
    - 这个指令直接用于 `load` 和 `store`（即没有使用过地址，也没有对地址进行计算）
    - 具体看函数 `isAllocaPromotable()` 的判断
3. 分析 `alloca` 的定义使用信息，并执行一些优化（见函数 `PromoteMem2Reg::run()`）
    - 移除没有 users 的 `alloca`
    - 如果一个 `alloca` 只有一个 def（即只有一个 `store` 指令），那么 users（都是 `load` 指令）可以替换成这个 `store` 的值。这里需要保证下面两个条件（见函数 `rewriteSingleStoreAlloca`）
      - 如果 `load` 和 `store` 在同一个基本块，则 `store` 应该在 `load` 前面
      - 如果二者在不同基本块，则需要保证 `load` 指令能被 `store` 支配
    - 如果某个 `alloca` 的所有 defs 和 uses 都在同一个基本块内，且 `store` 在 `load` 前面，则可以将基本块内的 `load` 替换成对应的 `store`
4. 放置 $\varphi$ 指令
    - 这里有一个剪枝：首先在所有存在 `load` 的基本块中，只有 `alloca` 是 live-in 的基本块才可能插入 $\varphi$ 指令（见函数 `ComputeLiveInBlocks()`）
    - 根据 `DefBlocks` 和 `LiveInBlocks` 计算**迭代支配边界**得到要插入的基本块（这里会对基本块根据序号进行排序，使得插入 $\varphi$ 指令的顺序和编号确定化）
      - 迭代支配边界：假设当前的 `def` 在基本块 `B`，在其支配边界 `DF(B)` 中插入 $\varphi$ 指令后，要将 `DF(DF(B))` 加入工作序列进行迭代
    - 放置 $\varphi$ 指令。对于同一个 `alloca`，一个基本块内只会插入一个 $\varphi$，并且此时指令的操作数还需要下一步进行更新（见函数 `QueuePhiNode()`）
5. 变量重命名。整个过程是一个 DFS，并且为了减小内存开销用迭代的方式做
    - 为每个 `alloca` 建立一个 map 记录对应的值。在 SSA 中，所有变量在函数入口都定义为 `Undef`，这样可以避免先使用后定义的问题，因此需要为所有变量先分配 `UndefValue`
    - 用迭代 DFS 的方式遍历基本块，基本块信息存在结构体 `RenamePassData` 中，内部包含了一个数组 `Values[]`（即 `IncomingVals[]`）记录当前基本块末尾某个 `alloca` 对应的 `Value`（一次迭代只填入一个前驱流过来的值）
    - `While (worklist != NULL)`
        + 标记当前基本块已经处理过
        + 如果块中有 $\varphi$ 指令，则遍历**所有先前添加**的 $\varphi$（注意程序中原来可能也有 $\varphi$，这里要和原来的 $\varphi$ 区分开来）：
            - 假设某个前驱到当前基本块有 `NumEdges` 条边，则为 $\varphi$ 指令添加 `NumEdges` 个来源，值为 `IncomingVals[L]`，同时设置 `IncomingVals[L] = Phi`
        + 如果当前基本块没有重复访问过，则对于基本块内的每条指令
            - 如果当前指令是 `load`，找到对应的 `alloca` `L`，然后替换成对应 `store` 进去的值，删除这条 `load`，并将所有 users 里的 `load` 替换成值 `IncomingVals[L]`
            - 如果当前指令是 `store`，找到对应的 `alloca` `L`，删除这条 `store`，并更新数组内的版本 `IncomingVals[L] = V`
    - 将没有访问过的后继基本块加入 `worklist`
6. 收尾：使用 `SimplifyInstruction` 化简 $\varphi$ 指令

在实现简单编译器的时候，可以只做 4、5 两步